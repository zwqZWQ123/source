---
title: 数据库原理（二）
date: 2017-04-03 14:10:17
tags:
- 事务
- 游标
- 存储过程
- 触发器
description: 数据库（Data  Base，简称DB）———— 存储在计算机存储介质上的、有一定组织形式的、可共享的、相互关联的数据集合。简单的说即为存储数据的仓库。

categories: 数据库
---
# 事务
&ensp;&emsp;&emsp;**事务**是数据库中一个单独的执行单元（Unit）,它通常由高级数据库操作语言（例如SQL）或编程语言（例如C++、Java等）编写的用户程序的执行所引起。当在数据库中更改数据成功时，在事务中更改的数据便会提交，不再改念。否则，事务就取消或者回滚，更改无效。
&ensp;&emsp;&emsp;**事务**必须满足4个属性，即**原子性（atomicity）**、**一致性(consistency)**、**隔离型（isolation）**、**持久性(durability)**，即ACID4种属性。
 1. 原子性
&ensp;&emsp;&emsp;**事务**是一个不可分割的整体，为了保证事务的总体目标，事务必须具有原子性，即当数据部分修改时，要么全执行，要么全不执行，即不允许事务部分地完成，避免了只执行这些操作的一部分而带来的错误。**原子性要求事务必须被完整执行**。
 2. 一致性
&ensp;&emsp;&emsp;一个事务执行之前和执行之后，数据库数据必须保持**一致性**状态。数据库的一致性状态应该满足**模式锁**执行的约束，那么在完整执行该事务后数据库仍然处于一致性状态。为了维护所有数据的完整性，在关系数据库中，所有规则必须应用到**事务**的修改上。数据库的一致性状态由用户来负责，由并发控制机制实现，例如*银行转账，转账前后两个账户金额之和应保持不变*。由于并发操作带来的数据不一致性包括丢失数据修改、读“脏”数据、不可重复读和产生“幽灵”数据。
 3. 隔离性
&ensp;&emsp;&emsp;**隔离性**也被称为**独立性**，当两个或多个事务并发执行时，为了保证数据的安全性，将一个事务内部的操作与事务的操作隔离起来，不被其他正在进行的事务看到，例如 ，任何一对事务T1和T2，对T1而言，T2要么在T1之前已经结束，要么在T1完成之后再开始执行。数据库有4种类型的事务隔离级别：**不提交的读**、**提交的读**、**可重复的读**和**串行化**。因为隔离性使得每个事务的更新在它被提交之前，对其他事务都是不可见的，所以，**实现隔离性是解决临时更新与消除级联回滚问题的一种方式**。
 4. 持久性
&ensp;&emsp;&emsp;**持久性**也被称为**永久性**，事务完成以后，DBMS保证它对数据库中的数据的修改是永久性的，当系统或介质发生故障时，该修改也永久保持。**持久性一般通过数据库备份与恢复来保证**。

&ensp;&emsp;&emsp;严格来说，数据库事务属性（ACID）都是由数据库管理系统来保证的，在整个应用程序运行过程中，应用无需去考虑数据库的ACID实现。
&ensp;&emsp;&emsp;一般情况下，通过执行**COMMIT**或**ROLLBACK**语句来终止事务。

* 当执行**COMMIT**语句时，自事务启动以来对数据库所做的一切更新就成为**永久性**的了，即被写入磁盘；
* 当执行**ROLLBACK**语句时，自事务启动以来对数据库所做的一切更改都会**被撤销**，并且数据库中内容返回到事务开始之前的状态。

&ensp;&emsp;&emsp;无论是什么情况，在事务完成时，都能保证回到一致状态。

**引申**：JDBC有哪些实务**隔离级别**？
&ensp;&emsp;&emsp;为了解决与“**与多个线程请求相同数据**”相关的问题，事务之间通常会用**锁**相互隔离离开。如今，大多数主流的数据库支持不同类型的锁。因此，JDBC API支持不同类型的事务，它们由**Connection对象**指派或确定。在JDBC中，定义了以下5种事务隔离级别：
1)**TRANSACTION_NONE JDB**。**不支持事务**。
2)**TRANSACTION_READ_UNCOMMITTED**。未提交读。说明在提交前一个事务可以看到另一事务的变化。这样读**“脏”数据**、**不可重复读**和**虚读**都是允许的。
3)**TRANSACTION_READ_COMMIT**。已提交读。说明读取未提交的数据是不允许的。这个级别仍然允许**不可重复读**和**虚读**产生。
4)**TRANSACTION_REPEATABLE_READ**。可重复读。说明事务保证能够再次读取相同的数据而不会失败，但**虚读**仍然会出现。
5)**TRANSACTION_SERIALIZABLE**。可序列化。是最高的事务级别，它防止读“脏”数据、不可重复读和虚读。
备注：
1⃣️**读“脏”数据**。一个事务读取了另一个事务尚未提交的数据。
2⃣️**不可重复读**。一个事务的操作导致另一个事务前后两次读取到不同的数据。
3⃣️**虚读**。一个事务的操作导致另一个事务前后两次查询的结果数据量不同。

# 游标
&ensp;&emsp;&emsp;数据库中，**游标**提供了一种对表中检索出的数据进行操作的灵活手段，它实际上是一种能从包含多条数据记录的结果集中每次提取一条记录的机制。
## 类型
* **隐式游标:**增删改等操作Oracle都会自动创建游标，暂时保存操作结果，也就是能够回滚的操作都会引发游标的创建。
* **显示游标：**由开发人员通过程序显式控制,用于从表中取出多行数据,并将多行数据一行一行的单独进行处理。

## 作用
* 游标允许应用程序对查询语句select返回的行结果集中的每一行进行相同或不同的操作，而不是一次对整个结果集进行同一种操作。
* 提供对基于游标位置而对表中数据进行删除或更新的功能。
* 游标还把作为**面向集合的数据库管理系统**和**面向行的程序设计**连接了起来，使两种数据处理方式能够进行“沟通”。

## 生命周期及步骤
&ensp;&emsp;&emsp;**游标的生命周期**包含有五个阶段：**声明游标**、**打开游标**、**读取游标数据**、**关闭游标**、**释放游标**。

|步骤|关键词|说明|
|:--|:--|:--|
|1|在DECLARE中cursor|声明游标，创建一个命名的查询语句|
|2|Open|打开游标|
|3|Fetch|取出游标中的一条记录装入变量|
|4|Close|释放游标|

## 优点
1. 在使用游标的表中，对行提供**删除**和**更新**的功能。
2. 游标将**面向集合的数据库管理系统**和**面向行的程序设计**连接了起来。

# 存储过程
##什么是存储过程
&ensp;&emsp;&emsp;SQL语句在执行时要先编译，然后再被执行。在大型数据库系统中，为了提高效率，将为了完成特定功能的SQL语句集进行编译优化后，存储在数据库服务器中，**用户通过制定存储过程的名字来调用执行**。
&ensp;&emsp;&emsp;下面为一个创建存储过程的常用语法：

```
create procedure sp_name @[参数名][类型]
                          as
                          begin
                          ......
                          end
```
调用存储过程语法：

```
exec sp_name[参数名]
```
删除存储过程语法：

```
drop procedure sp_name
```

## 存储过程与函数有什么区别与联系
&ensp;&emsp;&emsp;需要注意的是，存储过程不等于函数，二者虽然本质上没有区别，但还是有如下几个方面的不同：

1. **存储过程**一般是作为一个独立的部分来执行，而**函数**可以作为查询语句的一部分来调用。由于函数可以返回一个对象，因此它可以在查询语句中位于From关键字的后面。
2. 一般而言，**存储过程**实现的功能较复杂，而**函数**实现的功能针对性较强。
3. **函数**需要用括号包住输入的参数，且只能返回一个值或表对象，而**存储过程**可以返回多个参数。
4. **函数**可以嵌入在SQL中使用，可以在select中调用，**存储过程**则不行。
5. **函数**不能直接操作实体表，只能操作内建表。
6. **存储过程**在创建时即在服务器上进行了编译，其执行速度比**函数**快。

# 触发器
&ensp;&emsp;&emsp;**触发器**是一种特殊类型的**存储过程**，它由事件触发，而不是程序调用或手工启动，当数据库有特殊的操作时，这些操作由数据库中的事件来触发，自动完成这些SQL语句。**使用触发器可以用来保证数据的有效性和完整性，完成比约束更复杂的数据约束**。
## 触发器与存储过程的区别

|触发器|存储过程|
|-----|-------|
|当某类数据操纵DML语句发生时隐式地调用|从一个应用过程中显示地调用|
|在触发器体内禁止使用COMMIT和ROLLBACK语句|在过程体内可以使用所有PL／SQL块中都能使用的SQL语句，包括COMMIT和ROLLBACK语句|
|不能接受参数输入|可以接受参数输入|

## 触发器的分类
&ensp;&emsp;&emsp;根据SQL语句的不同，触发器可以分为DML触发器和DLL触发器。

* **DML触发器**是当数据库服务器发生**数据操纵语言（DML）**事件时执行的存储过程，有**After**和**Instead Of**这两种触发器。
 * **After触发器**被激活触发是在**记录改变之后**进行的一种触发器。
 * **Instead Of触发器**是在**记录变更之前**，去执行触发器本身所定义的操作，而不是执行原来SQL语句里的操作。
* **DLL触发器**是在响应**数据定义语言（DDL）**事件时执行的存储过程。

## 触发器的作用
触发器的作用主要表现为以下几个方面：

1. 增加安全性。
2. 利用**触发器**记录所进行的修改以及相关信息，跟踪用户对数据库的操作，实现审计。
3. 维护那些通过创建表时的声明约束不可能实现的复杂的完整性约束以及对数据库中特定事件进行监控与响应。
4. 实现复杂的非标准的数据库相关完整性规则、同步地复制表中的数据。
5. **触发器**是自动的，它们在对表的数据做了任何修改之后就会被激活，例如可以自动计算数据值，若数据的值达到了一定的要求，则进行特定的处理。以某企业财务管理为例，如果企业的资金出现短缺，并且达到某种程度时，则会发送警告信息。

**引申**：触发器分为**事前触发**和**事后触发**，这两者有什么区别？**语句级触发**和**行级触发**有什么区别？
&ensp;&emsp;&emsp;**事前触发**发生在事件发生之前，用于**验证一些条件或进行一些准备工作**；**事后触发**发生在事件之后，做**收尾工作**。**事前触发**可以**获得之前和新的字段值**，而**事后触发**可以**保证事务的完整性**。**语句级**出发可以在语句执行之前或之后执行，而**行级触发**在触发器所影响的每一行触发一次。



 













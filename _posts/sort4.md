---
title: 排序算法——归并排序
date: 2017-04-20 11:15:36
tags:
- 归并排序

description: 本篇博客讲述排序算法里的归并排序及七种算法的总结

categories: 排序算法
---
# 归并排序
## 基本思想
&ensp;&emsp;&emsp;归并排序是利用递归与分治技术将数据序列划分为越来越小的半子表，再对半子表排序，最后再用递归方法将排序好的半子表合并成为越来越大的有序序列。
&ensp;&emsp;&emsp;归并排序算法的原理如下：对于给定的一组记录（假设共有n个记录），首先将每两个相邻的长度为1的子序列进行归并，得到n/2（向上取整）个长度为2或1的有序子序列，再将其两两归并，反复执行此过程，直到得到一个有序序列。
&ensp;&emsp;&emsp;因此，归并排序的关键两步：
第一步：划分半子表；
第二步：合并半子表。
归并排序的示例：
![mergeSort](/sort4/mergeSort.jpg)
## 算法实现
```java 
public static void Merge(int array[],int p,int q,int r){
		int i,j,k,n1,n2;
		n1 = q-p+1;
		n2 = r-q;
		int[] L = new int[n1];
		int[] R = new int[n2];
		for (i = 0,k=p;  i< n1; i++,k++) {
			L[i] = array[k];
		}
		for (i = 0,k=q+1; i < n2; i++,k++) {
			R[i] = array[k];
		}
		for (i=0,j=0,k=p; i<n1&&j<n2;k++) {
			if (L[i] > R[j]) {
				array[k] = R[j];
				j++;
			} else {
				array[k] = L[i];
				i++;
			}
		}
		if (i<n1) {
			for (; i < n1; i++,k++) {
				array[k] = L[i];
			}
		}
		if (j<n2) {
			for (; j < n2; j++,k++) {
				array[k] = R[j];
			}
		}
	}
	
	public static void MergeSort(int[] array,int p,int r){
		if (p<r) {
			int q = (p+r)/2;
			MergeSort(array,p,q);
			MergeSort(array,q+1,r);
			Merge(array,p,q,r);
		}
	}
```

# 七大算法总结
<center> 表1 算法性能对比</center>

|排序算法|最好时间|平均时间|最坏时间|辅助存储|稳定性|备注|
|:--|:--|:--|:--|:--|:--|:--|
|简单选择排序|$O(n^2)$|$O(n^2)$|$O(n^2)$|$O(1)$|不稳定|n小时较好|
|直接插入排序|$O(n)$|$O(n^2)$|$O(n^2)$|$O(1)$|稳定|大部分已有序时较好|
|冒泡排序|$O(n)$|$O(n^2)$|$O(n^2)$|$O(1)$|稳定|n小时较好|
|希尔排序|$O(n)$|$O(nlogn)$|$O(n^s) 1<s<2$|$O(1)$|不稳定|s是所选分组|
|快速排序|$O(nlogn)$|$O(nlogn)$|$O(n^2)$|$O(logn)$|不稳定|n大时较好|
|堆排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(1)$|不稳定|n大时较好|
|归并排序|$O(nlogn)$|$O(nlogn)$|$O(nlogn)$|$O(n)$|稳定|n大时较好|

&ensp;&emsp;&emsp;从该表中可以得到以下几个方面的结论： 

1. 所有相等的数经过某种排序方法后，仍能保持它们在排序之前的相对次序，就称这种排序方法是稳定的，反之，就是非稳定的。例如，一组数排序前是$a_1,a_2,a_3,a_4,a_5$，其中$a_2=a_4$，经过某种排序后$a_1,a_2,a_4,a_3,a_5$，则说这种排序是稳定的，因为$a_2$排序前在$a_4$的前面，排序后它还是在$a_4$的前面。假如变成$a_1,a_4,a_2,a_3,a_5$就不是稳定的了。各种排序算法中**稳定的排序算法**有**直接插入排序**、**冒泡排序**和**归并排序**，而**不稳定的排序算法**有**希尔排序**、**快速排序**、**简单选择排序**和**堆排序**。
2. **时间复杂度为$O(n^2)$**的排序算法：直接插入排序、冒泡排序、快速排序、简单选择排序<br>
   **时间复杂度为$O(nlogn)$**的排序算法：堆排序、归并排序
3.  空间复杂度为$O(1)$的算法：简单选择排序、直接插入排序、冒泡排序、希尔排序、堆排序<br>空间复杂度为$O(n)$的算法：归并排序<br>空间复杂度为$O(logn)$的算法：快速排序
4. 虽然直接插入排序和冒泡排序的速度比较慢，但是当初始序列整体或局部有序时，这两种排序算法会有较高的效率。当初始序列整体或局部有序时，快速排序算法的效率会下降。当排序序列较小且不要求稳定性时，直接选择排序效率较好；要求稳定性时，冒泡排序效率较好。

&ensp;&emsp;&emsp;除了以上这几种排序算法以外，还有**位图排序**、**桶排序**、**基数排序**等。每种排序算法都有其最佳适用场合，例如，当待排序数据规模巨大，而对内存大小又没有限制时，位图排序是最高效的排序算法，所以，在选择使用排序算法时，一定要结合实际情况进行分析。







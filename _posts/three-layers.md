---
title: 三层架构及Java Web三层架构详解
date: 2017-03-15 22:14:34
tags: 三层架构
description: 三层架构、其与MVC模式的区别、详解Java Web三层架构
---
# 三层架构
&emsp;&emsp;&ensp;在现代的社会的软件开发体系中结构可以简单的概括是N层体系结构，N大于等于1，他们的开发方式不同：
&emsp;&emsp;&ensp;换句话说：**单机体系**（N＝1）、**Client/Server结构体系**（N＝2）、**多层体系结构**（N>2）。下面我们就对这三种体系结构进行简单的介绍和比较：
## 单机体系
&emsp;&emsp;&ensp;**单机体系**，一般情况下是针对某一种单一的应用，如字典软件、翻译软件等等，这种软件适用于单机状态。这种开发方式不适用于综合管理系统的开发。
## C/S结构
&emsp;&emsp;&ensp;C/S（Client/Server）结构，即客户机和服务器结构。C/S结构是在局域网上发展起来的，它具有数据集中管理的能力，在出现之初确实解决了很多计算机发展的难题，同时随着4GL语言的发展，用户的界面也逐渐丰富起来，在Client端的事物处理能力也使整个系统的性能得到全面的提高，并使管理信息系统得到快速的发展。       
&emsp;&emsp;&ensp;我们根据两层结构体系的概念来分解C／S结构的话，可以将他分为表现层（也叫表达层）和数据层。简单说：client直接访问DBserver为两层结构。 数据层提供数据存放的载体，而表现层则将数据层中数据取出，向用户进行显示。
&emsp;&emsp;&ensp;在两层体系结构中，表现层对数据库进行直接操作，且**大部分的商业处理逻辑（Business   Logic，数据之间的关系规则）也在表现层中实现。**
&emsp;&emsp;&ensp;两层结构在应用软件上的模型如图：
![C_S](/three-layers/C_S.png)
## 三层体系结构
&emsp;&emsp;&ensp;三层体系结构是N层体系结构的典型，所谓的三层体系结构就是将原来在两层体系结构中的商业逻辑部分从数据层和表现层中提炼出来，形成中间层，也叫组件层。简单的地说： client通过中间件等应用服务器访问DBserver就是三层结构。 所以三层就是：**显示层UI**、**商业逻辑层BLL**（Business  Logic  Layer）、**数据访问层DAL**(Data Access Layer)。

* **UI(表现层):**主要是指*与用户交互的界面*。用于接收用户输入的数据和显示处理后用户需要的数据。
* **BLL(业务逻辑层)**:*UI层和DAL层之间的桥梁。实现业务逻辑*。业务逻辑具体包含：验证、计算、业务规则等等。
* **DAL:(数据访问层)**:*与数据库打交道*。主要实现对数据的增、删、改、查。将存储在数据库中的数据提交给业务层，同时将业务层处理的数据保存到数据库。（当然这些操作都是基于UI层的。用户的需求反映给界面（UI），UI反映给BLL，BLL反映给DAL，DAL进行数据的操作，操作后再一一返回，直到将用户所需数据反馈给用户）
![threelayers](/three-layers/threelayers.png)
三层结构在应用软件上的模型如下图：
![model](/three-layers/model.png)

### 为什么使用三层？
使用三层架构的目的：解耦！！！
举个栗子：

1. 服务员（UI层）请假——另找服务员；厨师（BLL层）辞职——招聘另一个厨师；采购员（DAL）辞职——招聘另一个采购员；
2. 顾客反映：（1）你们店服务态度不好——服务员的问题。开除服务员；（2）你们店菜里有虫子——厨师的问题。换厨师；

任何一层发生变化都不会影响到另外一层！！！
### 与两层的区别？
**两层：**
![two](/three-layers/two.png)
当任何一个地方发生变化时，都需要重新开发整个系统。“多层”放在一层，分工不明确耦合度高——难以适应需求变化，可维护性低、可扩展性低。
**三层：**
![three](/three-layers/three.png)
发生在哪一层的变化，只需更改该层，不需要更改整个系统。层次清晰，分工明确，每层之间耦合度低——提高了效率，适应需求变化，可维护性高，可扩展性高。
### 三层的优缺点
**优势：**
1. 结构清晰、耦合度低
2. 可维护性高，可扩展性高
3. 利于开发任务同步进行，容易适应需求变化

**劣势：**
1. 降低了系统的性能。这是不言而喻的。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。
2. 有时会导致级联的修改。这种修改尤其体现在自上而下的方向。如果在表示层中需要增加一个功能，为保证其设计符合分层式结构，可能需要在相应的业务逻辑层和数据访问层中都增加相应的代码。
3. 增加了代码量，增加了工作量

# MVC模式与三层架构的区别
&emsp;&emsp;&ensp;三层架构和MVC是有明显区别的,**MVC应该是展现模式(三个加起来以后才是三层架构中的UI层)**，也就是说，MVC把三层架构中的UI层再度进行了分化，分成了控制器、视图、实体三个部分，控制器完成页面逻辑，通过实体来与界面层完成通话；而C层直接与三层中的BLL进行对话。
&emsp;&emsp;&ensp;**mvc可以是三层中的一个表现层框架，属于表现层。**三层和mvc可以共存。 三层是基于业务逻辑来分的，而mvc是基于页面来分的。 MVC主要用于表现层，3层主要用于体系架构，3层一般是表现层、中间层、数据层，其中表现层又可以分成M、V、C，(Model View Controller)模型－视图－控制器 。
&emsp;&emsp;&ensp;MVC模式是GUI界面开发的指导模式，基于表现层分离的思想把程序分为三大部分：Model-View-Controller，呈三角形结构。**Model**是指数据以及应用程序逻辑，**View**是指 Model的视图，也就是用户界面。这两者都很好理解，关键点在于Controller的角色以及三者之间的关系。在MVC模式中，Controller和View同属于表现层，通常成对出现。**Controller**被设计为处理用户交互的逻辑。一个通常的误解是认为Controller负责处理View和Model的交互，而实际上View和Model之间是可以直接通信的。由于用户的交互通常会涉及到Model的改变和View的更新，所以这些可以认为是Controller的副作用。
&emsp;&emsp;&ensp;**MVC和三层架构 MVC与三层架构类似么？** 

|MVC|三层架构|
|:---|:---|
|View|UI Layer|    
|Controller|Bussiness Logic Layer|  
|Model|Data Access Layer|
 其实这样是错误的。MVC是**表现模式**（Presentation Pattern）。 三层架构是**典型的架构模式**（Architecture Pattern）。 三层架构的分层模式是典型的上下关系，上层依赖于下层。但MVC作为表现模式是不存在上下关系的，而是相互协作关系。即使将MVC当作架构模式，也不是分层模式。MVC和三层架构基本没有可比性，是应用于不同领域的技术。

# Java Web 三层架构详解
## 框架技术
&emsp;&emsp;&ensp;著名的软件大师Ralph Johnson对框架(Framework)进行了如下的定义： 框架是整个系统或系统的一部分的可重用设计，由一组抽象的类及其实例间的相互作用方式组成。
&emsp;&emsp;&ensp;框架一般具有即插即用的可重用性、成熟的稳定性以及良好的团队协作性。J2EE复杂的多层结构决定了大型的J2EE项目需要运用框架和设计模式来控制软件质量。目前，市场上出现了一些商业的、开源的基于J2EE的应用框架，其中主流的框架技术有：**基于MVC模式的Struts框架和基于IoC模式的 Spring框架以及对象/关系映射框架Hibernate等。**
## 表示层框架Struts
&emsp;&emsp;&ensp;**Struts**是一个在JSP Model2基础上实现的MVC框架，主要分为模型(Model)、视图(Viewer)和控制器(Controller)三部分，其主要的设计理念是通过控制器将表现逻辑和业务逻辑解耦，以提高系统的可维护性、可扩展性和可重用性。
&emsp;&emsp;&ensp;分析Struts框架中的MVC组件：

* **视图**：视图部分主要由JSP页面组成，其中没有流程逻辑、业务逻辑和模型信息，只有标记。Struts自身包含了一组标记库(TagLib)，这也是Struts的精华之一，灵活运用它们可以简化JSP页面的代码，提高开发效率。
* **控制器**：Struts中的Controller主要是其自身提供的ActionServlet。ActionServlet接收所有来自客户端的请求并根据配置文件(struts-config.xml)中的定义将控制转移到适当的Action对象。
* **模型**：Struts没有定义具体Model层的实现，Model层通常是和业务逻辑紧密相关的，有持续化的要求。目前在商业领域和开源世界，都有一些优秀的工具可以为Model层的开发提供便利。

## 业务逻辑层框架Spring
&emsp;&emsp;&ensp;**Spring**是一个解决了许多J2EE开发中常见问题并能够替代EJB技术的强大的轻量级框架。这里所说的轻量级指的是 Spring框架本身，而不是指Spring只能用于轻量级的应用开发。Spring的轻盈体现在其框架本身的基础结构以及对其他应用工具的支持和装配能力。与EJB这种庞然大物相比，Spring可使程序研发人员把各个技术层次之间的风险降低。
&emsp;&emsp;&ensp;Spring框架的核心是**控制反转IoC**(Inversion of Control)/**依赖注入DI(Dependence Injection)**机制。IoC是指**由容器中控制组件之间的关系**（这里，容器是指为组件提供特定服务和技术支持的一个标准化的运行时的环境）而**非传统实现中由程序代码直接操控**，这种将控制权由程序代码到外部容器的转移，称为“反转”。DI是对IoC更形象的解释，即由容器在运行期间动态地将依赖关系(如构造参数、构造对象或接口)注入到组件之中。 Spring采用**设值注入**(使用Setter方法实现依赖)和**构造子注入**(在构造方法中实现依赖)的机制，**通过配置文件管理组建的协作对象，创建可以构造组件的IoC容器**。这样，不需要编写工厂模式、单例模式或者其他构造的方法，就可以通过容器直接获取所需的业务组件。
&emsp;&emsp;&ensp;Spring框架由七个定义明确的模块组成，且每个模块或组件都可以单独存在，或者与其他一个或多个模块联合实现。
**Spring Core Container**是一个用来管理业务组件的IoC容器，是Spring应用的核心；
**Spring DAO**和**Spring ORM**不仅提供数据访问的抽象模块，还集成了对Hibernate、JDO和iBatis等流行的对象关系映射框架的支持模块，并且提供了缓冲连接池、事务处理等重要的服务功能，保证了系统的性能和数据的完整性；
**Sprnig Web**模块提供了Web应用的一些抽象封装，可以将Struts、Webwork等Web框架与Spring整合成为适用于自己的解决方案。
&emsp;&emsp;&ensp;Spring框架可以成为企业级应用程序一站式的解决方案，同时它也是模块化的框架，允许开发人员自由地挑选适合自己应用的模块进行开发。Spring框架式是一个松耦合的框架，框架的部分耦合度被设计为最小，在各个层次上具体选用哪个框架取决于开发者的需要。
## 数据持久层框架Hibernate
&emsp;&emsp;&ensp;**O/R mapping技术**是为了解决关系型数据库和面向对象的程序设计之间不匹配的矛盾而产生的。**Hibernate**是目前最为流行的O/R mapping框架，它在关系型数据库和Java对象之间做了一个自动映射，使得程序员可以以非常简单的方式实现对数据库的操作。
&emsp;&emsp;&ensp;**Hibernate**通过对JDBC的封装，向程序员屏蔽了底层的数据库操作，使程序员专注于OO程序的开发，有助于提高开发效率。程序员访问数据库所需要做的就是为持久化对象编制xml映射文件。
&emsp;&emsp;&ensp;底层数据库的改变只需要简单地更改初始化配置文件(**hibernate.cfg.xml或者hibernate.properties**)即可，不会对应用程序产生影响。
&emsp;&emsp;&ensp;Hibernate有自己的**面向对象的查询语言HQL**，HQL功能强大，支持目前大部分主流的数据库，如Oracle、DB2、MySQL、 Microsoft SQL Server等，是目前应用最广泛的O/R映射工具。Hibernate为快速开发应用程序提供了底层的支持。
## 集成SSH的J2EE框架
&emsp;&emsp;&ensp;集成SSH框架的系统从职责上分为四层：**表示层**、**业务逻辑层**、**数据持久层**和**域模块层**。其中使用Struts作为系统的整体基础架构，负责MVC的分离，在Struts框架的模型部分，利用Hibernate框架对持久层提供支持，业务层用Spring支持。具体做法是：用面向对象的分析方法根据需求提出一些模型，将这些模型实现为基本的Java对象，然后编写基本的DAO接口，并给出Hibernate的DAO实现，采用Hibernate架构实现的DAO类来实现Java类与数据库之间的转换和访问，最后由Spring完成业务逻辑。
&emsp;&emsp;&ensp;系统的基本业务流程是：
**在表示层中**，首先通过JSP页面实现交互界面，负责传送请求(Request)和接收响应(Response)，然后Struts根据配置文件 (struts-config.xml)将ActionServlet接收到的Request委派给相应的Action处理。
**在业务层中**，管理服务组件的 Spring IoC容器负责向Action提供业务模型(Model)组件和该组件的协作对象数据处理(DAO)组件完成业务逻辑，并提供事务处理、缓冲池等容器组件以提升系统性能和保证数据的完整性。
**在持久层中**，则依赖于Hibernate的对象化映射和数据库交互，处理DAO组件请求的数据，并返回处理结果。
&emsp;&emsp;&ensp;采用上述开发模型，不仅实现了视图、控制器与模型的彻底分离，而且还实现了业务逻辑层与持久层的分离。这样无论前端如何变化，模型层只需很少的改动，并且数据库的变化也不会对前端有所影响，大大提高了系统的可复用性。而且由于不同层之间耦合度小，有利于团队成员并行工作，大大提高了开发效率。


